{
  "hash": "7d6614c3d29e33b846de123fe878795d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hypothesis Testing 2\"\nsubtitle: \"Reletionship Between Two Variables\"\ndate: today\ndate-format: long\nfooter: \"[IAFF 6501 Website](https://quant4ia.rocks/)\"\nlogo: images/iaff6501-logo.png\nformat:\n  revealjs:\n    theme: [simple, custom.scss]\n    transition: fade\n    slide-number: true\n    #multiplex: true\n    chalkboard: true\nexecute:\n  echo: true\n  message: false\n  warning: false\n  freeze: auto\n---\n\n\n## Hypotheses\n\n<br>\n\n- **Null hypothesis:** there is no relationship between treatment and outcome, the difference is due to chance\n- **Alternative hypothesis:** there is a relationship, the difference is not due to chance\n\n## Approach\n\n<br>\n\n- Under the null hypothesis, treatment has **NO** impact on *y* (the outcome)\n- This means that if we were to change the values of the treatment variable, the values on *y* **would stay the same**\n\n## Approach\n\n- So...we can simulate the null distribution by:\n    - Reshuffling the treatment variable\n    - Calculating the treatment effect\n    - Repeating many times\n    \n. . . \n\n- Then we can ask: how likely would we be to observe the treatment effect in our data, *if there is no effect of the treatment*?\n\n## Résumé Experiment Example\n\nBertrand and Mullainathan studied racial discrimination in responses to job applications in Chicago and Boston. They sent 4,870 résumés, randomly assigning names associated with different racial groups.\n- Data are in `openintro` package as an object called `resume`\n- I will save as `myDat`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(openintro)\nmyDat <- resume \n```\n:::\n\n\n## Callbacks by Race\n\n<br>\n\nRemember, race of applicant is randomly assigned.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\nmns <- myDat |>\n  group_by(race) |> \n  summarize(calls = mean(received_callback))\nmns\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 2\n  race   calls\n  <chr>  <dbl>\n1 black 0.0645\n2 white 0.0965\n```\n\n\n:::\n:::\n\n\n##\n\n<br> \n\nLet's save the means for white and black applicants.\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_white = mns$calls[2]\nmean_black = mns$calls[1]\n```\n:::\n\n\n##\n\n<br>\n\nAnd calculate the treatment effect. The treatment effect is the difference in means.\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nteffect <- mean_white - mean_black\nteffect\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.03203285\n```\n\n\n:::\n:::\n\n\n## {.center}\n\nBefore formal tests, let's look at the data--the estimates **and** the confidence intervals...\n\n##\n\n<br>\n\nFirst, let's make the CIs for the white applicants.\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidymodels)\nboot_df_white <- myDat |>\n  filter(race == \"white\") |> \n  specify(response = received_callback) |>  \n  generate(reps = 15000, type = \"bootstrap\") |> \n  calculate(stat = \"mean\")\nlower_bound_white <- boot_df_white |> summarize(lower_bound_white = quantile(stat, 0.025)) |> pull() \nupper_bound_white <- boot_df_white |> summarize(upper_bound_white = quantile(stat, 0.975)) |> pull() \n```\n:::\n\n\n## \n\n<br>\n\nNow, let's create the CIs for black applicants.\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nboot_df_black <- myDat |>\n  filter(race == \"black\") |> \n  specify(response = received_callback) |>  \n  generate(reps = 15000, type = \"bootstrap\") |> \n  calculate(stat = \"mean\")\nlower_bound_black <- boot_df_black |> summarize(lower_bound_black = quantile(stat, 0.025)) |> pull() \nupper_bound_black <- boot_df_black |> summarize(upper_bound_black = quantile(stat, 0.975)) |> pull() \n```\n:::\n\n\n## \n\n<br>\n\nNow, let's tidy the data for plotting.\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotData <- tibble(\n  race = c(\"Black\", \"White\"),\n  meanCalls = c(mean_black, mean_white),\n  lower95 = c(lower_bound_black, lower_bound_white),\n  upper95 = c(upper_bound_black, upper_bound_white)\n)\nplotData\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 4\n  race  meanCalls lower95 upper95\n  <chr>     <dbl>   <dbl>   <dbl>\n1 Black    0.0645  0.0550  0.0743\n2 White    0.0965  0.0850  0.108 \n```\n\n\n:::\n:::\n\n\n## Plot\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](week-4.2_files/figure-revealjs/unnamed-chunk-8-1.png){width=960}\n:::\n:::\n\n\n## Plot\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(plotData, aes(y = meanCalls, x = race, ymin = lower95, ymax = upper95)) +\n  geom_col(fill = \"steelblue4\") +\n  geom_errorbar(width = .05) +\n  theme_bw()  +\n  ylim(0, .15) +\n  labs(x = \"Race of Applicant\",\n       y = \"Call Back Rate\")\n```\n:::\n\n\n## Is this evidence of racial discrimination?\n\n<br>\n\n- What is the null hypothesis?\n\n. . .\n\n- What is the alternative hypothesis?\n\n. . .\n\n- How can we formally test the null hypothesis to decide whether to reject it?\n\n## Formal Hypothesis Test\n\n<br>\n\n::: incremental\n- Calculate the difference in means (White - Black)\n- Shuffle the race variable\n- Calculate the difference in means for the shuffled data\n- Repeat many times\n- Simulates the null distribution of **differences** in callbacks\n:::\n\n## Hypothetical Original Data \n\n<br>\n\n| Applicant | Race  | Callback |\n|-----------|-------|----------|\n| A         | Black | Yes      |\n| B         | Black | No       |\n| C         | Black | No       |\n| D         | White | Yes      |\n| E         | White | No       |\n| F         | White | No       |\n\n## Step 1: Calculate Original Difference in Callback Rates\n\n<br> \n\n- **Objective:** Understand initial association between race and callback rates\n\n## Step 2: Shuffle (Permute) the Race Variable\n\n<br>\n\n- **Method:** Randomly reassign race labels, keeping callback outcomes fixed\n\n## Hypothetical Shuffled Data\n\n<br>\n\n| Applicant | Race (Shuffled) | Callback |\n|-----------|-----------------|----------|\n| A         | White           | Yes      |\n| B         | Black           | No       |\n| C         | White           | No       |\n| D         | White           | Yes      |\n| E         | Black           | No       |\n| F         | Black           | No       |\n\n## Step 3: Calculate Difference in Callback Rates Again\n\n<br> \n\n- **After Shuffling:** Calculate the difference in callback rates between Black and White groups\n- **Purpose:** Determine if observed difference is due to chance\n\n## Repeat Many Times\n\n<br>\n\n- Repeat shuffling 5000 times to generate a distribution of differences by chance\n- **Test:** Compare observed difference to null distribution to assess effect of race on callbacks\n- If observed difference is extreme (p-value is low), reject the null hypothesis\n\n## Simulating with `tidymodels`\n\n<br>\n\nIn real life we are going to use the `tidymodels` package to do the simulation for us.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnull_dist <- myDat |>\n  specify(response = received_callback, explanatory = race) |>\n  hypothesize(null = \"independence\") |>\n  generate(5000, type = \"permute\") |>\n  calculate(stat = \"diff in means\", \n            order = c(\"white\", \"black\")) # \n```\n:::\n\n\n## Visualize\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](week-4.2_files/figure-revealjs/unnamed-chunk-11-1.png){width=960}\n:::\n:::\n\n\n## Visualize\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = null_dist, mapping = aes(x = stat)) +\n  geom_histogram(binwidth = 0.01, fill = \"steelblue4\") +\n  labs(title = \"Null distribution + Estimate\",\n       x = \"Estimated Difference under the Null\") +     \n  geom_vline(xintercept = teffect, linetype=\"dotted\", \n                color = \"black\", size=1) + theme_bw()\n```\n:::\n\n\n## Calculate the p-value\n\n<br>\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnull_dist |>\n  filter(stat > teffect) |>\n  summarise(p_value = n()/nrow(null_dist)) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n  p_value\n    <dbl>\n1       0\n```\n\n\n:::\n:::\n\n\n## What should we conclude?\n\n<br>\n\n::: incremental\n- The p-value is very small (below .05 threshold)\n- Therefore, we **reject** the null hypothesis: the racial gap is extremely unlikely to have occurred due to chance alone\n- This is evidence of racial discrimination\n:::\n\n## Your Turn! {.smaller}\n\n<br>\n\n- Use the **gender** variable in the `resume` data to assess whether there is gender discrimination in call backs\n- Plot means and 95% confidence intervals for the call back rate for men and women\n- Write the null and alternative hypotheses\n- Simulate the null distribution\n- Visualize the null distribution and the gender gap\n- Calculate the p-value\n- What do you conclude from your test?  \n\n\n",
    "supporting": [
      "week-4.2_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}